---
title: "Setting up your workflow with dynamic vars"
author: 
  - name: Giulia Pais
    affiliation: | 
     San Raffaele Telethon Institute for Gene Therapy - SR-Tiget, 
     Via Olgettina 60, 20132 Milano - Italia
    email: giuliapais1@gmail.com, calabria.andrea@hsr.it
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('ISAnalytics')`"
vignette: >
  %\VignetteIndexEntry{setup_workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
```{r GenSetup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL
    ## Related to
    ## https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```

```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Bib setup
library("RefManageR")

## Write bibliography information
bib <- c(
    R = citation(),
    BiocStyle = citation("BiocStyle")[1],
    knitr = citation("knitr")[1],
    RefManageR = citation("RefManageR")[1],
    rmarkdown = citation("rmarkdown")[1],
    sessioninfo = citation("sessioninfo")[1],
    testthat = citation("testthat")[1],
    ISAnalytics = citation("ISAnalytics")[1],
    lubridate = citation("lubridate")[1],
    purrr = citation("purrr")[1]
)

library(ISAnalytics)
library(BiocStyle)
library(DT)
main_fig <- fs::path("../man", "figures", "dyn_vars_general.png")
```

# Introduction

This vignette demonstrates how to properly setup your workflow 
with `ISAnalytics` using the "dynamic vars" system.

From `ISAnalytics 1.5.4` onwards, a new system here referred to as 
"dynamic vars" has been implemented to improve the flexibility of the package,
by allowing multiple input formats based on user needs rather than enforcing
hard-coded names and structures. In this way, users that do not follow the
standard name conventions used by the package have to put minimal effort
into making their inputs compliant to the package requirements.

There are 5 main categories of inputs you can customize:

* The **"mandatory IS vars"**: this set of variables is used to uniquely 
identify integration events across several functions implemented in the 
package
* The **"annotation IS vars"**: this set of variables holds the names of
the columns that contain genomic annotations
* The **"association file columns"**: this set contains information on how 
metadata is structured
* The **"VISPA2 stats specs"**: this set contains information on the format
of pool statistics files produced automatically by VISPA2
* The **"matrix files suffixes"**: this set contains all default file names
for each quantification type and it is used by automated import functions

# General approach

The general approach is based on the specification of 
predefined tags and their associated information in the form of simple
data frames with a standard structure, namely:

names                | types  | transform          | flag   | tag 
---------------------|--------|--------------------|--------|-----
`<name of the column>` | `<type>` | `<a lambda or NULL>` | `<flag>` | `<tag>`

where

* `names` contains the name of the column as a character
* `types` contains the type of the column. Type should be expressed as a 
string and should be in one of the allowed types
    * `char` for character (strings)
    * `int` for integers 
    * `logi` for logical values (TRUE / FALSE)
    * `numeric` for numeric values
    * `factor` for factors
    * `date` for generic date format - note that functions that
    need to read and parse files will try to guess the format and parsing
    may fail
    * One of the accepted date/datetime formats by `r CRANpkg("lubridate")`, 
    you can use `ISAnalytics::date_formats()` to view the accepted formats
* `transform`: a purrr-style lambda that is applied immediately after importing.
This is useful to operate simple transformations like removing unwanted 
characters or rounding to a certain precision. Please note that these lambdas
need to be functions that accept a vector as input and only operate a 
<u>transformation</u>, aka they output a vector of the same length as the 
input. For more complicated applications that may require the value of other
columns, appropriate functions should be manually applied post-import.
* `flag`: as of now, it should be set either to `required` or `optional` - 
some functions internally check for only required tags presence and if those
are missing from inputs they fail, signaling failure to the user
* `tag`: a specific tag expressed as a string - see Section \@ref(tags)

![Dynamic variables general approach](`r main_fig`)

# Tags

As already mentioned, certain functions included in the package require 
the presence of specific tags (and associated column names) in the input
to work properly. 
You can always check what a tag means and where it is used by using the
function `inspect_tags()` and providing in input the tags you want to check
as a character vector.

```{r}
inspect_tags("chromosome")
```

You should make sure the tag matches the right information in your inputs
by looking at the description of the tag.
It is also possible to add entries that are not associated with any tag.
Here is an overview of the critical tags for each 
category.

## Mandatory IS vars

```{r echo=FALSE}
all_tags <- available_tags()
all_tags[, needed_in := purrr::map_chr(needed_in,
                                       ~ paste0(.x, collapse = ", "))]
mand_tags <- all_tags[eval(rlang::sym("dyn_vars_tbl")) == "mand_vars", 
                      mget(c("tag", "needed_in", "description"))]
annot_tags <- all_tags[eval(rlang::sym("dyn_vars_tbl")) == "annot_vars", 
                      mget(c("tag", "needed_in", "description"))]
af_tags <- all_tags[eval(rlang::sym("dyn_vars_tbl")) == "af_vars", 
                      mget(c("tag", "needed_in", "description"))]
iss_tags <- all_tags[eval(rlang::sym("dyn_vars_tbl")) == "iss_vars", 
                      mget(c("tag", "needed_in", "description"))]
```

```{r echo=FALSE}
datatable(
  mand_tags,
  class = "stripe",
  options = list(dom = 't'), 
  rownames = FALSE
)
```

The presence of all mandatory IS vars is also checked and used
in other functions - for example, when importing matrices it is ensured
that all mandatory variables are present in the input,
as declared in the look up table.
Some functions may require information that needs to be specified as input,
always check the documentation if you have doubts.

## Annotation IS vars

```{r echo=FALSE}
datatable(
  annot_tags,
  class = "stripe",
  options = list(dom = 't'), 
  rownames = FALSE
)
```

Although genomic annotations are not necessarily required to work with 
ISAnalytics, some operations do require annotation - if you're working with
matrices that are not annotated you can either annotate them with a tool of
your choice or skip the steps that require annotation.

## Association file columns

```{r echo=FALSE}
datatable(
  af_tags,
  class = "stripe",
  options = list(dom = 't'), 
  rownames = FALSE
)
```

Some tags in this table are not associated with any function yet, but they
exist for potential new features that will be added in the future.

## VISPA2 stats specs

```{r echo=FALSE}
datatable(
  iss_tags,
  class = "stripe",
  options = list(dom = 't'), 
  rownames = FALSE
)
```

NOTE: VISPA2 stats files usually follow standard naming conventions. 
If the pipeline launch was configured with default parameters, do not change
this lookup table.

# Customizing dynamic vars

For each category of dynamic vars there are 3 functions:

* A getter - returns the current lookup table
* A setter - allows the user to change the current lookup table
* A resetter - reverts all changes to defaults

Setters will take in input the new variables, validate and eventually
change the lookup table. If validation fails an error will be thrown instead,
inviting the user to review the inputs. Moreover, if some of the critical
tags for the category are missing, a warning appears, with a list of the 
missing ones.

Let's take a look at some examples.

On package loading, all lookup tables are set to default values. 
For example, for mandatory IS vars we have:

```{r}
mandatory_IS_vars(TRUE)
```

Let's suppose our matrices follow a different standard, and integration events
are characterized by 5 fields, like so (the example contains random data):

chrom   | position | strand | gap    | junction 
--------|----------|--------|--------|---------
"chr1"  | 342543   | "+"    | 100    | 50
...     | ...      | ...    | ...    | ...

To make this work with ISAnalytics functions, we need to compile the lookup
table like this:

```{r}
new_mand_vars <- tibble::tribble(
  ~names, ~types, ~transform, ~flag, ~tag,
  "chrom", "char", ~stringr::str_replace_all(.x, "chr", ""), "required",
  "chromosome",
  "position", "int", NULL, "required", "locus",
  "strand", "char", NULL, "required", "is_strand",
  "gap", "int", NULL, "required", NA_character_,
  "junction", "int", NULL, "required", NA_character_
)
```

Notice that we have specified a transformation for the "chromosome" tag:
in this case we would like to have only the number of the chromosome without
the prefix "chr" - this lambda will get executed immediately after import.

To set the new variables simply do:

```{r}
set_mandatory_IS_vars(new_mand_vars)
mandatory_IS_vars(TRUE)
```

If you don't specify a critical tag, a warning message is displayed:

```{r}
new_mand_vars[1, ]$tag <- NA_character_
set_mandatory_IS_vars(new_mand_vars)
mandatory_IS_vars(TRUE)
```

If you change your mind and want to go back to defaults:

```{r}
reset_mandatory_IS_vars()
mandatory_IS_vars(TRUE)
```

The principle is the same for annotation IS vars, association file columns and
VISPA2 stats specs. Here is a summary of the functions for each:

* mandatory IS vars: `mandatory_IS_vars()`, `set_mandatory_IS_vars()`,
`reset_mandatory_IS_vars()`
* annotation IS vars: `annotation_IS_vars()`, `set_annotation_IS_vars()`,
`reset_annotation_IS_vars()`
* association file columns: `association_file_columns()`, 
`set_af_columns_def()`, `reset_af_columns_def()`
* VISPA2 stats specs: `iss_stats_specs()`, `set_iss_stats_specs()`,
`reset_iss_stats_specs`

Matrix files suffixes work slightly different:

```{r}
matrix_file_suffixes()
```

To change this lookup table use the function `set_matrix_file_suffixes()`:
the function will ask to specify a suffix for each quantification and for
both annotated and not annotated versions. These suffixes are used in the
automated matrix import function when scanning the file system.

To reset all lookup tables to their default configurations you can also 
use the function `reset_dyn_vars_config()`, which reverts all changes.

# FAQs

## Do I have to do this every time the package loads?

At the moment yes, but it is just temporary, so we suggest to save a script
with the necessary configurations and execute it before proceeding with the
analyses. In future updates we will add the possibility to export and
import configurations. Stay tuned!


# Reproducibility

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# Bibliography

This vignette was generated using `r Biocpkg("BiocStyle")` `r Citep(bib[["BiocStyle"]])`
with `r CRANpkg("knitr")` `r Citep(bib[["knitr"]])` and `r CRANpkg("rmarkdown")` `r Citep(bib[["rmarkdown"]])` running behind the scenes.

Citations made with `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`.

```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```

